# 논리아키텍처설계 가이드

## 목적

유저스토리와 UI/UX 설계를 기반으로 서비스 간 관계 중심의 논리 아키텍처를 설계함. Context Map 스타일의 컴포넌트 다이어그램으로 시각화하여 이후 HighLevel 아키텍처 정의의 기반을 제공함.

## 입력 (이전 단계 산출물)

| 산출물 | 파일 경로 | 활용 방법 |
|--------|----------|----------|
| 아키텍처 패턴 설계서 | `docs/design/architecture.md` | 선정된 패턴 기반 설계 |
| 유저스토리 | `docs/plan/design/userstory.md` | 서비스 책임 매칭 |
| UI/UX 설계서 | `docs/plan/design/uiux/uiux.md` | 데이터 플로우 파악 |

## 출력 (이 단계 산출물)

| 산출물 | 파일 경로 |
|--------|----------|
| 논리 아키텍처 설계서 | `docs/design/logical-architecture.md` |
| 논리 아키텍처 다이어그램 | `docs/design/logical-architecture.mmd` |

## 방법론

### 1. 준비

유저스토리, UI/UX설계서, 아키텍처패턴을 분석 및 이해합니다.

### 2. 실행

#### 2.1 논리 아키텍처 설계서 작성

`logical-architecture.md` 파일에 아래 항목을 필수 포함하고 필요 시 항목을 추가합니다.

- **개요**: 설계 원칙, 핵심 컴포넌트 정의
- **서비스 아키텍처**
  - 서비스별 책임
  - 서비스 간 통신 전략
- **주요 사용자 플로우**
- **데이터 흐름 및 캐싱 전략**
- **확장성 및 성능 고려사항**
- **보안 고려사항**
- **논리아키텍처 다이어그램** (별도 `.mmd` 파일 경로 참조)

#### 2.2 논리 아키텍처 다이어그램 작성

`logical-architecture.mmd` 파일에 Mermaid 형식으로 작성합니다.

**통신 전략**:
- **동기 통신**: 즉시 응답이 필요한 단순 조회
- **캐시 우선**: 자주 사용되는 데이터는 캐시에서 직접 읽기
- **비동기 처리**: 외부 API 다중 호출 등 장시간 작업

**의존성 표현 방법**:
- 실선 화살표(`→`): 동기적 의존성 (필수)
- 비동기 화살표(`->>`): 비동기 의존성 (fire-and-forget)
- 점선 화살표(`-->`): 선택적 의존성 또는 느슨한 결합
- 양방향 화살표(`↔`): 상호 의존성
- 의존성 레이블에 목적 명시 (예: "멤버 정보 조회")
- 플로우 라벨 형식: [요청서비스약어]액션 (예: [Trip]AI 일정 생성 요청)

**다이어그램 작성 원칙**:
- Context Map 스타일로 서비스 내부 구조는 생략하고 서비스 간 관계에 집중
- 클라이언트에서 API Gateway로는 단일 연결선으로 표현
- 사용자 관점의 컴포넌트 다이어그램 작성

#### 2.3 Mermaid 스크립트 검사 실행

작성 완료 후 'Mermaid문법검사가이드'에 준용하여 스크립트를 검증합니다.

### 3. 검토

- 작성원칙 준수 검토
- 스쿼드 팀원 리뷰: 누락 및 개선 사항 검토
- 수정 사항 선택 및 반영

## 출력 형식

```markdown
# 논리 아키텍처 설계서

## 개요
### 설계 원칙
{설계 원칙 목록}

### 핵심 컴포넌트 정의
| 컴포넌트 | 책임 |
|---------|------|
| {컴포넌트명} | {책임 설명} |

## 서비스 아키텍처
### 서비스별 책임
{서비스별 책임 기술}

### 서비스 간 통신 전략
{동기/비동기/캐시 전략 기술}

## 주요 사용자 플로우
{유저스토리별 주요 흐름 기술}

## 데이터 흐름 및 캐싱 전략
{데이터 흐름 및 캐싱 전략 기술}

## 확장성 및 성능 고려사항
{고려사항 기술}

## 보안 고려사항
{보안 고려사항 기술}

## 논리 아키텍처 다이어그램
{logical-architecture.mmd 파일 참조}
```

```mmd
graph TB
    Client[클라이언트] --> GW[API Gateway]
    GW --> SvcA[서비스 A]
    GW --> SvcB[서비스 B]
    SvcA -->|"[A]데이터 조회"| SvcB
    SvcB -->>|"[B]이벤트 발행"| SvcC[서비스 C]
```

## 품질 기준

### 완료 체크리스트
- [ ] 유저스토리와 매칭 확인
- [ ] Mermaid 문법 검증 통과
- [ ] 불필요한 추가 설계 없음
- [ ] 물리적 배포 구조를 이 단계에서 결정하지 않음
- [ ] 서비스 내부 구조 생략하고 서비스 간 관계에 집중
- [ ] 클라이언트에서 API Gateway로 단일 연결선 표현

## 주의사항

- **유저스토리와 매칭**: 불필요한 추가 설계 금지
- UI/UX설계서의 '사용자 플로우' 참조하여 설계
- '아키텍처패턴'에 선정된 클라우드 디자인 패턴을 적용하여 설계
- 물리적 배포 구조(인프라, 컨테이너 배치 등)는 이 단계에서 결정하지 않음
- Mermaid 스크립트 검증: https://mermaid.live/edit 에서 붙여넣어 확인
- 논리아키텍처 다이어그램 예시: https://raw.githubusercontent.com/cna-bootcamp/clauding-guide/refs/heads/main/samples/sample-논리아키텍처.mmd
- 설계 공통 원칙: `resources/guides/design/common-principles.md` 참조
